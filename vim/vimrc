set nocompatible " be iMproved

" install plugins
source $HOME/.vim/plug.vim

syntax enable
set t_Co=256
set encoding=utf8

" gruvbox dark
let g:gruvbox_contrast_dark = "hard"
set background=dark
colorscheme gruvbox

" line numbers
set number

" with a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","

nmap <leader>w :w!<cr>
nmap <leader>q :q<cr>
nmap <leader>ne :NERDTreeToggle<cr>
nnoremap <leader>f :Files<cr>

" splits - <leader>[s]plit + hjkl
nmap <leader>sh :leftabove  vsplit<CR>
nmap <leader>sl :rightbelow vsplit<CR>
nmap <leader>sk :leftabove  split<CR>
nmap <leader>sj :rightbelow split<CR>

" jk is escape
inoremap jk <esc>

" hightlight the current line
set cursorline

" tab = 2 spaces
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set smarttab

" do not wrap in the middle of a word
set wrap
set linebreak

set smartindent
set autoindent

" visual autocomplete for command menu
set wildmenu

" redraw only when we need to
set lazyredraw

" search and highlight as characters are entered
set incsearch
set hlsearch

" Use <C-L> to clear the highlighting of :set hlsearch.
if maparg('<C-L>', 'n') ==# ''
  nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
endif

" ignore case when searching
set ignorecase

" trying to be smart about cases, when searching
set smartcase

" always show current position
set ruler

" show matching brackets
set showmatch
set mat=2

set laststatus=2
set hidden

" no annoying sound on errors
set noerrorbells
set novisualbell
set t_vb=
set tm=500

" properly disbale sound on errors on MacVim
if has("gui_macvim")
    autocmd GUIEnter * set vb t_vb=
endif

" turn backup off, since most stuff is in SVN, git, etc anyway
set nobackup
set nowb
set noswapfile

" use <Tab> to cycle through windows
nnoremap <Tab> <C-w>w
nnoremap <S-Tab> <C-w>W

" switch to last opened buffer
nmap <Leader><Leader> <C-^>

" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" Delete trailing white space on save, useful for some filetypes ;)
fun! CleanExtraSpaces()
    if exists("b:noStripWhitespace")
        return
    endif

    let save_cursor = getpos(".")
    let old_query = getreg('/')
    silent! %s/\s\+$//e
    call setpos('.', save_cursor)
    call setreg('/', old_query)
endfun

if has("autocmd")
    autocmd FileType markdown let b:noStripWhitespace=1
    autocmd BufWritePre * :call CleanExtraSpaces()
endif
